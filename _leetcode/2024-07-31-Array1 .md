---
title: "Array 1"
date: 2024-07-31
permalink: /leetcode/array-1/
tags:
  - Array
  - Binary Search
excerpt: "074 binary search, 27"
---

# Array[^dmsxl]
[^dmsxl]: 代码随想录-数组:https://programmercarl.com/数组理论基础.html.



# Leetcode 
  * [074 Binary Search](https://leetcode.com/problems/binary-search/)
  * []

## Binary Search[^binarySearch]
[^binarySearch]:Leetcode-074 Binary Search: https://leetcode.com/problems/binary-search/.

### Description
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

**Example 1**
```Python
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
```

**Example 2**
```Python
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
```

### Note
#### General Idea
Use left and right node to define the range for exploration (Initially ```left = 0`` ``right = len(nums)```), so that ``mid`` can be used for binary search. 

**Difficulties**
  * How to define ```mid```.
  * How to update ```left``` and ```right```.
  * Conditions of while loop.

#### Variable Scope and Memory Management in Java**
  - **Scope**: The scope of a variable determines where the variable is accessible within the program. In Java, the scope is determined by where the variable is declared.
    - **Local Variables**: Declared inside a method or a code block (like a while loop or for loop) and are only accessible within that block.
    - **Instance Variables**: Declared inside a class but outside any method, accessible to all methods within the class.
Class Variables (Static Variables): Declared with the static keyword inside a class, shared across all instances of the class.
  - **Lifecycle**: The lifecycle of a variable refers to the period during which the variable exists in memory.
    - **Local Variables**: Their lifecycle starts when the block is entered and ends when the block is exited.
    - **Instance Variables**: Their lifecycle starts when an object is created and ends when the object is garbage collected.
    - **Class Variables**: Their lifecycle starts when the class is loaded and ends when the class is unloaded.

**Benefits of Declaring Variables Inside a Loop**
When a variable such as ```int mid``` was decleared inside the ```while loop```.
<table>
  <tr>
    <td><img src="/images/leetcode-array1-1.png" alt="Image 1"></td>
    <td><img src="/images/leetcode-array1-2.png" alt="Image 2"></td>
  </tr>
</table>
The variable mid is a local variable with a scope limited to each iteration of the while loop. Here are the benefits:

1. **Automatic Memory Release**: At the end of each iteration, the local variable mid goes out of scope, and Java's garbage collector can reclaim the memory used by mid. This helps in managing memory efficiently.
2. **Memory Reuse**: In the next iteration, the JVM can allocate memory for mid again, potentially reusing the same memory space. This can reduce memory fragmentation and improve overall memory usage.
3. **Avoid Unintentional Modifications**: Declaring variables inside the loop ensures they are re-initialized with each iteration, preventing accidental modifications that might occur if the variable were declared outside the loop.

### Solution
A detail solution explaination[^binarySearchSolution] can be found [here](https://programmercarl.com/0704.二分查找.html#思路)
[^binarySearchSolution]:代码随想录-704二分法查找：https://programmercarl.com/0704.二分查找.html#思路.
  * Time complexity: O(log n)
  * Memory complexity: O(1)
**Python**
```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        right = len(nums) - 1
        left = 0
        while (left <= right):
            mid = left + (right - left) // 2
            if (target > nums[mid]):
                left = mid + 1
            elif(target < nums[mid]):
                right = mid - 1
            else:
                return mid
                
        return -1
```
**Java**
```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while(left <= right){
            int mid = left + (right - left) / 2;

            if(nums[mid] < target){
                left = mid + 1;
            }
            else if (nums[mid] > target){
                right = mid - 1;
            }
            else{
                return mid;
            }
        }
        return -1;
    }
}
```

